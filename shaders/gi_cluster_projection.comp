#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_scalar_block_layout : enable

#include "common.glsl"

layout (local_size_x = 64) in;

layout(set = 0, binding = 0) uniform _Config { GIConfig config; };
layout(std140, set = 0, binding = 1) readonly buffer _InputBuffer1 { vec4 probeRelightColors[]; };
layout(std430, set = 0, binding = 2) readonly buffer _InputBuffer2 { float clusterProjectionMatrices[]; };
layout(std430, set = 0, binding = 3) readonly buffer _InputBuffer3 { ClusterReceiverInfo clusterReceiverInfos[]; };
layout(std430, set = 0, binding = 4) readonly buffer _InputBuffer4 { int probes[]; };
layout(set = 0, binding = 5) buffer _OutputBuffer { vec4 outColors[]; };

const float PI  = 3.14159265358979323846264;

float window(float l, float w) {
	if(l == 0) {
		return 1;
	}
	else if(l >= w) {
		return 0;
	}

	float x = PI * l / w;
	x = sin(x) / x;

	return pow(x, 1);
}

#define WINDOWING 10

float baked_window[] = {1, 0.983632, 0.935489, 0.858394, 0.756827, 0.63662, 0.504551, 0.367883};
int degree[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

void main()
{
	uint gID = gl_GlobalInvocationID.x;

	if(gID < config.clusterCount * config.pcaCoefficient) {
		outColors[gID] = vec4(0.0);

		uint currCluster = gID / config.pcaCoefficient;
		uint currCoeff = gID % config.pcaCoefficient;

		int clusterProbeCount = clusterReceiverInfos[currCluster].probeCount;
		int clusterProbeOffset = clusterReceiverInfos[currCluster].probeOffset;
		int clusterCoeffCount = clusterReceiverInfos[currCluster].svdCoeffCount;
		int clusterCoeffOffset = clusterReceiverInfos[currCluster].svdCoeffOffset;
		int projectionMatrixOffset = clusterReceiverInfos[currCluster].projectionMatrixOffset;

		if(currCoeff >= clusterCoeffCount) {
			return;
		}

		for(int i = 0; i < clusterProbeCount; i++) {
			int probeIndex = clusterProbeOffset + i;
			int currProbe = probes[probeIndex];
			for(int k = 0; k < config.basisFunctionCount; k++) {
				//float w = window(floor(sqrt(float(k))), WINDOWING);
				float w = baked_window[degree[k]];
				vec4 color = probeRelightColors[currProbe * config.basisFunctionCount + k];
				uint index = projectionMatrixOffset + currCoeff * config.basisFunctionCount * clusterProbeCount + i * config.basisFunctionCount + k;
				outColors[clusterCoeffOffset + currCoeff] += w * color * clusterProjectionMatrices[index];
			}
		}
	}
}
/*
TODO
Inputs:
	- Result from gi_probe_projection
		(probe count) * (basis function count) vec3/vec4 colors
	- Cluster projection matrices
		1000s of 32 * ((probe count) * (basis function count)))
Calculation:
	- Matrix multiplication for each cluster
Output: 
	- 32 * 1 matrix for each cluster (1000s)
*/